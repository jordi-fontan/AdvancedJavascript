Ensuring immutability: ESLint
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] So, I talked in the previous video about the importance of immutability in functional programming. Immutability allows us to avoid the many bugs that occur in computer programs as a side effect of state change. It also means that we don't have to worry about using private variables to avoid changes coming from unexpected places, since we simply can't make changes to any piece of data. That being said, if we want to ensure complete immutability in JavaScript, there's something we need to keep in mind. While using the const keyword prevents us from directly changing the value of a piece of data, for example if we say const x equals five, we can't simply say x equals six, since this will throw an error. However, using const in JavaScript is a little funny when working with arrays and objects. For example, if we define an array called numbers, like this, const numbers, one two three four five, we can never directly redefine numbers as a different array like this, numbers equals hello. But we can modify the individual elements of an array like this. Numbers zero equals 100. And JavaScript won't complain about this at all, even though we've defined our numbers array using the const keyword. Also, if we're not careful, we can accidentally call a mutating array method such as reverse, on a supposedly immutable array like this. Numbers dot reverse, and this will actually modify the original array without any complaint from JavaScript. And the same is true for objects as well. If we define an object called person, const person, with name and age properties, name John Doe, age 34, we can never directly redefine person as another object like this, person equals name Bob, but if we try and reset a property of our object like this, person dot name equals Bob, JavaScript won't complain even though this is modifying our data. Now, I'm going to show you an approach that we can use to prevent mutation in our code, and this is by using ESLint rules. If you've never worked with or heard of ESLint before, it's an extremely helpful tool that helps you catch errors or stylistic flaws in your code. ESLint won't add anything extra to your code, we can simply run it and it looks at our existing code and tells us any problems it finds, for example if we're doing accidental mutation. Now there are many different ESLint plugins that we can use depending on our coding style and concerns, there are ones that check for correct indentation, ones that make sure you put semicolons at the end of every line, et cetera. But for the purposes of this course, the Lint rules we're interested in are the ones that will automatically tell us if we try and mutate anything in our code. There are several existing plugins that already implement this functionality, and the one we're going to use is called ESLint plugin immutable. I'm not going to go through all the details about ESLint here, but I'll just walk you through the steps required to get this set up.
